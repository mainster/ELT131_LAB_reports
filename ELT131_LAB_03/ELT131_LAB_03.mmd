Title:      Report ELT131 LAB 03
Author:     Del Basso, Manuel
Date:       24-03-2017
Location:   WHZ
Footicon:   ./pics/whz.png

ELT131 - Lab 03 report
==============================
[TOC]

## Introduction ##
>In Part1 and Part2 of ELT131_LAB_03 __no__ TI-RTOS is used. The goal is to measure the interrupt latency time of the TMS320F28335 in a __non__-OS environment.
In Part1, the code will be placed in __RAM__ - memory, as this is the fastest available memory type. This setup is used to estimate the best case for the given hardware.
In Part2, the code will be placed in FLASH - memory, as this is the default memory type. This setup is used to compare interrupt latencys of non-OS setups, once executed from __RAM__ and once executed from FLASH.
In the Part3 of this exercise, TI-RTOS and it's HWI functionality is used.

__Used components:__

 - Hardware
     - TI TMS320F28335 Explorer Kit for TI C2000â„¢ F28x family of microprocessors, controller card Delfino
     - Oscilloscope: PC-USB Scope _PCSU1000, velleman_
 - Software
     - Code Composer Studio Version: 7.1.0.00016 (CCS7)
     - Board support via ti's [__controlSUITE__](http://www.ti.com/tool/controlsuite?DCMP=mcu_controlsuite&HQS=controlsuite) v3.4.5
     - SYS/BIOS
         + Version: 6.45.02.31
     - TI-RTOS for C2000
         + Version: 2.16.1.14
 - Development Plattform
     + ```lsb_release -d``` <span style="margin-left: 1em;">Linux Mint 18 Sarah (LinuxMint)</span>
     + ```uname -rpo``` <span style="margin-left: 1em;">4.4.0-57-generic x86_64 GNU/Linux</span>

# Interrupt latency and jitter (Non-OS) #
## Non-OS setup running from RAM (Part 1) ##

>Add the final code of files "ePWM1.c" and "ELT131_03_part1.c" to your report.

### Non-OS setup sources ###
<details markdown=1>
<summary><h4 class="sp foldable"><span class="codehd">md_epwm.c</span></h4></summary>
@codeimport: "./ELT131_LAB_03_NON-OS/MD_F2833x_LIB/md_epwm.c"
</details>

<details markdown=1>
<summary><h4 class="sp foldable"><span class="codehd">md_epwm.h</span></h4></summary>
@codeimport: "./ELT131_LAB_03_NON-OS/MD_F2833x_LIB/md_epwm.h"
</details>

<details markdown=1>
<summary><h4 class="sp foldable"><span class="codehd">ELT131_LAB_03_01.c</span></h4></summary>
@codeimport: "./ELT131_LAB_03_NON-OS/ELT131_LAB_03_01.c"
</details>

<details markdown=1>
<summary><h4 class="sp foldable"><span class="codehd">ELT131_LAB_03_01.h</span></h4></summary>
@codeimport: "./ELT131_LAB_03_NON-OS/ELT131_LAB_03_01.h"
</details>
<div style="height: 1em;"></div>

### Measure Interrupt Latency and jitter
>Add the oscilloscope screenshots for signal ePWM1 to your report. Test the signal at frequencies: 200 kHz, 20 kHz, 2 kHz, 200 Hz and 20 Hz.

<figure class="oszi" markdown=1> <img src="./pics/epwm_rect_200Hz.png" title="Square wave signal generated from ePWM1 mmodul" class="noborder oszi"><figcaption>Square wave signal generated from ePWM1 mmodul</figcaption> </figure>

>Add the oscilloscope screenshots for the interrupt latency to your report.

<figure class="oszi" markdown=1> <img src="./pics/non-os_ram_jitter_100Hz_20ns.png" title="Interrupt latency and jitter @100Hz of __non-OS__ setup running from __RAM__" class="noborder oszi"><figcaption>Interrupt latency and jitter of __non-OS__ setup running from __RAM__ @$\;\si{100Hz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/non-os_ram_jitter_200Hz_20ns.png" title="Interrupt latency and jitter @200Hz of __non-OS__ setup running from __RAM__" class="noborder oszi"><figcaption>Interrupt latency and jitter of __non-OS__ setup running from __RAM__ @$\;\si{200Hz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/non-os_ram_jitter_2kHz_20ns.png" title="Interrupt latency and jitter @2kHz of __non-OS__ setup running from __RAM__" class="noborder oszi"><figcaption>Interrupt latency and jitter of __non-OS__ setup running from __RAM__ @$\;\si{2kHz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/non-os_ram_jitter_20kHz_20ns.png" title="Interrupt latency and jitter @20kHz of __non-OS__ setup running from __RAM__" class="noborder oszi"><figcaption>Interrupt latency and jitter of __non-OS__ setup running from __RAM__ @$\;\si{20kHz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/non-os_ram_jitter_200kHz_20ns.png" title="Interrupt latency and jitter @200kHz of __non-OS__ setup running from __RAM__" class="noborder oszi"><figcaption>Interrupt latency and jitter of __non-OS__ setup running from __RAM__ @$\;\si{200kHz}\;$</figcaption> </figure>

<div style="height: 1em;"></div>

### Measurement results documentation  ###
>Fill in Table 1.9. and add it to the report.

Latency and jitter table running __non-OS__ setup from __RAM__.

| ePWM1A Freq     | Interrupt latency | Interrupt jitter |
|:---------------:|:-----------------:|:----------------:|
| $\si\{100Hz\}$  | $\si\{220 ns\}$   | $\si\{26 ns\}$   |
| $\si\{200Hz\}$  | $\si\{220 ns\}$   | $\si\{26 ns\}$   |
| $\si\{2kHz\}$   | $\si\{220 ns\}$   | $\si\{26 ns\}$   |
| $\si\{20kHz\}$  | $\si\{220 ns\}$   | $\si\{26 ns\}$   |
| $\si\{200kHz\}$ | $\si\{220 ns\}$   | $\si\{26 ns\}$   |

## Non-OS setup running from FLASH (Part 2) ##
>Add the final code of file "ELT131_03_part2.c" to your report.

<details markdown=1>
<summary><h4 class="sp foldable"><span class="codehd">ELT131_LAB_03_02.c</span></h4></summary>
@codeimport: "./ELT131_LAB_03_NON-OS/ELT131_LAB_03_02.c"
</details>

<details markdown=1>
<summary><h4 class="sp foldable"><span class="codehd">ELT131_LAB_03_01.h</span></h4></summary>
@codeimport: "./ELT131_LAB_03_NON-OS/ELT131_LAB_03_02.h"
</details>
<div style="height: 1em;"></div>

### Measure Interrupt Latency and jitter (FLASH) ###
>Add the oscilloscope screenshots for the interrupt latency and jitter to your report.

<h4 class="sp"><span>Latency measurements</span></h4>

<figure class="oszi" markdown=1> <img src="./pics/non-os_flash_latency_100Hz_50ns.png" title="Interrupt latency @100Hz of __non-OS__ setup running from __FLASH__" class="noborder"><figcaption>Interrupt latency of __non-OS__ setup running from __FLASH__ @$\;\si{100Hz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/non-os_flash_latency_200Hz_50ns.png" title="Interrupt latency @200Hz of __non-OS__ setup running from __FLASH__" class="noborder"><figcaption>Interrupt latency of __non-OS__ setup running from __FLASH__ @$\;\si{200Hz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/non-os_flash_latency_2kHz_50ns.png" title="Interrupt latency @2kHz of __non-OS__ setup running from __FLASH__" class="noborder"><figcaption>Interrupt latency of __non-OS__ setup running from __FLASH__ @$\;\si{2kHz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/non-os_flash_latency_20kHz_50ns.png" title="Interrupt latency @20kHz of __non-OS__ setup running from __FLASH__" class="noborder"><figcaption>Interrupt latency of __non-OS__ setup running from __FLASH__ @$\;\si{20kHz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/non-os_flash_latency_200kHz_50ns.png" title="Interrupt latency @200kHz of __non-OS__ setup running from __FLASH__" class="noborder"><figcaption>Interrupt latency of __non-OS__ setup running from __FLASH__ @$\;\si{200kHz}\;$</figcaption> </figure>

<h4 class="sp"><span>Jitter measurements</span></h4>

<figure class="oszi" markdown=1> <img src="./pics/non-os_flash_jitter_100Hz_20ns.png" title="Interrupt jitter @100Hz of __non-OS__ setup running from __FLASH__" class="noborder"><figcaption>Interrupt jitter of __non-OS__ setup running from __FLASH__ @$\;\si{100Hz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/non-os_flash_jitter_200Hz_20ns.png" title="Interrupt jitter @200Hz of __non-OS__ setup running from __FLASH__" class="noborder"><figcaption>Interrupt jitter of __non-OS__ setup running from __FLASH__ @$\;\si{200Hz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/non-os_flash_jitter_2kHz_20ns.png" title="Interrupt jitter @2kHz of __non-OS__ setup running from __FLASH__" class="noborder"><figcaption>Interrupt jitter of __non-OS__ setup running from __FLASH__ @$\;\si{2kHz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/non-os_flash_jitter_20kHz_20ns.png" title="Interrupt jitter @20kHz of __non-OS__ setup running from __FLASH__" class="noborder"><figcaption>Interrupt jitter of __non-OS__ setup running from __FLASH__ @$\;\si{20kHz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/non-os_flash_jitter_200kHz_20ns.png" title="Interrupt jitter @200kHz of __non-OS__ setup running from __FLASH__" class="noborder"><figcaption>Interrupt jitter of __non-OS__ setup running from __FLASH__ @$\;\si{200kHz}\;$</figcaption> </figure>

### Measurement results documentation  ###
>Fill in Table 2.4. and add it to the report.

Latency and jitter table running __non-OS__ setup from __FLASH__.

| ePWM1A Freq     | Interrupt latency | Interrupt jitter |
|:---------------:|:-----------------:|:----------------:|
| $\si\{100Hz\}$  | $\si\{330 ns\}$   | $\si\{26 ns\}$   |
| $\si\{200Hz\}$  | $\si\{330 ns\}$   | $\si\{25 ns\}$   |
| $\si\{2kHz\}$   | $\si\{330 ns\}$   | $\si\{24 ns\}$   |
| $\si\{20kHz\}$  | $\si\{330 ns\}$   | $\si\{24 ns\}$   |
| $\si\{200kHz\}$ | $\si\{330 ns\}$   | $\si\{24 ns\}$   |

# Interrupt latency and jitter (RTOS) #
All TI-RTOS projects are run from FLASH.

## TI-RTOS - Hardware interrupt setup (HWI, Part 3) ##
>Add the final code of file "ELT131_03_03.c" to your report.

Some basic UART/SCI and encoder read-in functions has been added to the project. The ePWM1 frequencies are selectable via on-board hex encoder switch.

The interrupt latency and jitter measurements have been performed several times in order to assess any deviations introduced by the additional idle task (query encoder GPIOs). According to the interrupt __latency__, the next oscilloscope screenshots shows that there are no relevant changes. After taking a look at the resulting interrupt jitter, a measureable influence can be pointed out.

<figure class="oszi" markdown=1> <img src="./pics/picsTry1/os_irq_latency_idle_is_enc.png" title="Interrupt latency @200kHz of __RTOS__ setup including an __idle task__ to query encoder GPIOs" class="noborder"><figcaption>Interrupt latency of __RTOS__ setup including an __idle task__ to query encoder GPIOs @$\;\si{200kHz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/picsTry1/os_irq_latency_idle_is_NONE.png" title="Interrupt latency @200kHz of __RTOS__ setup __without__ any idle task" class="noborder"><figcaption>Interrupt latency of __RTOS__ setup __without__ any idle task @$\;\si{200kHz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/picsTry1/os_irq_jitter_idle_is_enc.png" title="Interrupt jitter @200kHz of __RTOS__ setup including an __idle task__ to query encoder GPIOs" class="noborder"><figcaption>Interrupt jitter of __RTOS__ setup including an __idle task__ to query encoder GPIOs @$\;\si{200kHz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/picsTry1/os_irq_jitter_idle_is_NONE.png" title="Interrupt jitter @200kHz of __RTOS__ setup __without__ any idle task" class="noborder"><figcaption>Interrupt jitter of __RTOS__ setup __without__ any idle task @$\;\si{200kHz}\;$</figcaption> </figure>

<details markdown=1>
<summary><h4 class="sp foldable"><span class="codehd">ELT131_LAB_03_RTOS_3.c</span></h4></summary>
@codeimport: "./ELT131_LAB_03_RTOS_3/ELT131_LAB_03_RTOS_3.c"
</details>

<details markdown=1>
<summary><h4 class="sp foldable"><span class="codehd">ELT131_LAB_03_RTOS_3.h</span></h4></summary>
@codeimport: "./ELT131_LAB_03_RTOS_3/ELT131_LAB_03_RTOS_3.h"
</details>

<details markdown=1>
<summary><h4 class="sp foldable"><span class="codehd">md_uart_sci.c</span></h4></summary>
@codeimport: "./ELT131_LAB_03_RTOS_3/MD_F2833x_LIB/md_uart_sci.c"
</details>

<details markdown=1>
<summary><h4 class="sp foldable"><span class="codehd">md_uart_sci.h</span></h4></summary>
@codeimport: "./ELT131_LAB_03_RTOS_3/MD_F2833x_LIB/md_uart_sci.h"
</details>

<details markdown=1>
<summary><h4 class="sp foldable"><span class="codehd">md_bsp_explorer.c</span></h4></summary>
@codeimport: "./ELT131_LAB_03_RTOS_3/MD_F2833x_LIB/md_bsp_explorer.c"
</details>

<details markdown=1>
<summary><h4 class="sp foldable"><span class="codehd">md_bsp_explorer.h</span></h4></summary>
@codeimport: "./ELT131_LAB_03_RTOS_3/MD_F2833x_LIB/md_bsp_explorer.h"
</details>
<div style="height: 1em;"></div>

>Copy the final version of the cfg-script "app.cfg" to your report. To reduce the size of the file, remove all comment lines and copy the rest into you report file for inspection.

In order not to miss the teaching goal, all measurements were carried out without any idle task. To quickly switch between the different PWM frequencies, the value of the hex encoder is polled during initialization. As part of a layout correction (FTDI TTL232 SCIA interface swapped Rx <=> Tx), the TMDSPREX28335 has been extended by a reset button.

<details markdown=1>
<summary><h4 class="sp foldable"><span class="codehd">app.cfg</span></h4></summary>
```java
@codeimport: "./ELT131_LAB_03_RTOS_3/app.cfg"
@codeimport_nocomments
```
</details>
<div style="height: 1em;"></div>

>Add the oscilloscope screenshots for the interrupt latency and jitter to your report.

<h4 class="sp"><span>Latency measurements</span></h4>

<figure class="oszi" markdown=1> <img src="./pics/os_hwi_latency_100Hz_100ns.png" title="Interrupt latency @100Hz of HWI __RTOS__ setup" class="noborder"><figcaption>Interrupt latency of __HWI__ RTOS setup @$\;\si{100Hz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_hwi_latency_200Hz_100ns.png" title="Interrupt latency @200Hz of HWI __RTOS__ setup" class="noborder"><figcaption>Interrupt latency of __HWI__ RTOS setup @$\;\si{200Hz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_hwi_latency_2kHz_100ns.png" title="Interrupt latency @2kHz of HWI __RTOS__ setup" class="noborder"><figcaption>Interrupt latency of __HWI__ RTOS setup @$\;\si{2kHz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_hwi_latency_20kHz_100ns.png" title="Interrupt latency @20kHz of HWI __RTOS__ setup" class="noborder"><figcaption>Interrupt latency of __HWI__ RTOS setup @$\;\si{20kHz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_hwi_latency_200kHz_100ns.png" title="Interrupt latency @200kHz of HWI __RTOS__ setup" class="noborder"><figcaption>Interrupt latency of __HWI__ RTOS setup @$\;\si{200kHz}\;$</figcaption> </figure>

<h4 class="sp"><span>Jitter measurements</span></h4>

<figure class="oszi" markdown=1> <img src="./pics/os_hwi_jitter_100Hz_20ns.png" title="Interrupt jitter @100Hz of HWI __RTOS__ setup" class="noborder"><figcaption>Interrupt jitter of __HWI__ RTOS setup @$\;\si{100Hz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_hwi_jitter_200Hz_20ns.png" title="Interrupt jitter @200Hz of HWI __RTOS__ setup" class="noborder"><figcaption>Interrupt jitter of __HWI__ RTOS setup @$\;\si{200Hz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_hwi_jitter_2kHz_20ns.png" title="Interrupt jitter @2kHz of HWI __RTOS__ setup" class="noborder"><figcaption>Interrupt jitter of __HWI__ RTOS setup @$\;\si{2kHz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_hwi_jitter_20kHz_20ns.png" title="Interrupt jitter @20kHz of HWI __RTOS__ setup" class="noborder"><figcaption>Interrupt jitter of __HWI__ RTOS setup @$\;\si{20kHz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_hwi_jitter_200kHz_20ns.png" title="Interrupt jitter @200kHz of HWI __RTOS__ setup" class="noborder"><figcaption>Interrupt jitter of __HWI__ RTOS setup @$\;\si{200kHz}\;$</figcaption> </figure>

### Measurement results documentation  ###
>Fill in Table 3.8. and add it to the report.

Latency and jitter table running __HWI RTOS__ setup from FLASH.

| ePWM1A Freq     | Interrupt latency | Interrupt jitter |
|:---------------:|:-----------------:|:----------------:|
| $\si\{100Hz\}$  | $\si\{1.64 Âµs\}$  | $\si\{28 ns\}$   |
| $\si\{200Hz\}$  | $\si\{1.60 Âµs\}$  | $\si\{85 ns\}$   |
| $\si\{2kHz\}$   | $\si\{1.60 Âµs\}$  | $\si\{57 ns\}$   |
| $\si\{20kHz\}$  | $\si\{1.60 Âµs\}$  | $\si\{89 ns\}$   |
| $\si\{200kHz\}$ | $\si\{1.60 Âµs\}$  | $\si\{120 ns\}$  |

## TI-RTOS - Software interrupt setup (SWI, Part 4) ##
>Add the final code of file "ELT131_03_04.c" to your report.

<details markdown=1>
<summary><h4 class="sp foldable"><span class="codehd">ELT131_LAB_03_RTOS_4.c</span></h4></summary>
@codeimport: "./ELT131_LAB_03_RTOS_4/ELT131_LAB_03_RTOS_4.c"
</details>

<details markdown=1>
<summary><h4 class="sp foldable"><span class="codehd">ELT131_LAB_03_RTOS_4.h</span></h4></summary>
@codeimport: "./ELT131_LAB_03_RTOS_4/ELT131_LAB_03_RTOS_4.h"
</details>
<div style="height: 1em;"></div>

>Copy the final version of the cfg-script "app.cfg" to your report. To reduce the size of the file, remove all comment lines and copy the rest into you report file for inspection.

<details markdown=1>
<summary><h4 class="sp foldable"><span class="codehd">app.cfg</span></h4></summary>
```java
@codeimport: "./ELT131_LAB_03_RTOS_4/app.cfg"
@codeimport_nocomments
```
</details>
<div style="height: 1em;"></div>

>Add the oscilloscope screenshots for the interrupt latency and jitter to your report.

<h4 class="sp"><span>Latency measurements</span></h4>

<figure class="oszi" markdown=1> <img src="./pics/os_swi_latency_100Hz_500ns.png" title="Interrupt latency @100Hz of SWI __RTOS__ setup" class="noborder"><figcaption>Interrupt latency of __SWI__ RTOS setup @$\;\si{100Hz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_swi_latency_200Hz_500ns.png" title="Interrupt latency @200Hz of SWI __RTOS__ setup" class="noborder"><figcaption>Interrupt latency of __SWI__ RTOS setup @$\;\si{200Hz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_swi_latency_2kHz_500ns.png" title="Interrupt latency @2kHz of SWI __RTOS__ setup" class="noborder"><figcaption>Interrupt latency of __SWI__ RTOS setup @$\;\si{2kHz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_swi_latency_20kHz_500ns.png" title="Interrupt latency @20kHz of SWI __RTOS__ setup" class="noborder"><figcaption>Interrupt latency of __SWI__ RTOS setup @$\;\si{20kHz}\;$</figcaption> </figure>

According to the next oscilloscope picture we are not able to service IRQs fast enough when the ePWM1 module operates at $f_{ePWM}\;=\;\si{200kHz}$ and TI-RTOS is configured for SWI.

<figure class="oszi" markdown=1> <img src="./pics/picsTry1/os_swi_no_200kHz_100ns_v2_because.png" title="Overall IRQ service time @20kHz, SWI __RTOS__ setup" class="noborder"><figcaption>Overall IRQ service time of SWI __RTOS__ setup @$\;\si{20kHz}\;$</figcaption> </figure>

<h4 class="sp"><span>Jitter measurements</span></h4>

<figure class="oszi" markdown=1> <img src="./pics/os_swi_jitter_100Hz_100ns.png" title="Interrupt jitter @100Hz of SWI __RTOS__ setup" class="noborder"><figcaption>Interrupt jitter of __SWI__ RTOS setup @$\;\si{100Hz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_swi_jitter_200Hz_100ns.png" title="Interrupt jitter @200Hz of SWI __RTOS__ setup" class="noborder"><figcaption>Interrupt jitter of __SWI__ RTOS setup @$\;\si{200Hz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_swi_jitter_2kHz_100ns.png" title="Interrupt jitter @2kHz of SWI __RTOS__ setup" class="noborder"><figcaption>Interrupt jitter of __SWI__ RTOS setup @$\;\si{2kHz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_swi_jitter_20kHz_100ns.png" title="Interrupt jitter @20kHz of SWI __RTOS__ setup" class="noborder"><figcaption>Interrupt jitter of __SWI__ RTOS setup @$\;\si{20kHz}\;$</figcaption> </figure>

### Measurement results documentation  ###
>Fill in Table 4.5. and add it to the report.

Latency and jitter table running __SWI RTOS__  setup from FLASH.

| ePWM1A Freq     | Interrupt latency | Interrupt jitter |
|:---------------:|:-----------------:|:----------------:|
| $\si\{100Hz\}$  | $\si\{3.76 Âµs\}$  | $\si\{150 ns\}$  |
| $\si\{200Hz\}$  | $\si\{3.76 Âµs\}$  | $\si\{130 ns\}$  |
| $\si\{2kHz\}$   | $\si\{3.76 Âµs\}$  | $\si\{130 ns\}$  |
| $\si\{20kHz\}$  | $\si\{3.76 Âµs\}$  | $\si\{150 ns\}$  |
| $\si\{200kHz\}$ | $NA$              | $NA$             |

## TI-RTOS - Zero latency interrupt setup (ZLI, Part 5) ##
>Add the final code of file "ELT131_03_05.c" to your report.

<details markdown=1>
<summary><h4 class="sp foldable"><span class="codehd">ELT131_LAB_03_RTOS_5.c</span></h4></summary>
@codeimport: "./ELT131_LAB_03_RTOS_5/ELT131_LAB_03_RTOS_5.c"
</details>

<details markdown=1>
<summary><h4 class="sp foldable"><span class="codehd">ELT131_LAB_03_RTOS_5.h</span></h4></summary>
@codeimport: "./ELT131_LAB_03_RTOS_5/ELT131_LAB_03_RTOS_5.h"
</details>
<div style="height: 1em;"></div>

>Copy the final version of the cfg-script "app.cfg" to your report. To reduce the size of the file, remove all comment lines and copy the rest into you report file for inspection.

<details markdown=1>
<summary><h4 class="sp foldable"><span class="codehd">app.cfg</span></h4></summary>
```java
@codeimport: "./ELT131_LAB_03_RTOS_5/app.cfg"
@codeimport_nocomments
```
</details>
<div style="height: 1em;"></div>

>Add the oscilloscope screenshots for the interrupt latency and jitter to your report.

<h4 class="sp"><span>Latency measurements</span></h4>

<figure class="oszi" markdown=1> <img src="./pics/os_zli_latency_100Hz_50ns.png" title="Interrupt latency @100Hz of __ZLI__ RTOS setup" class="noborder"><figcaption>Interrupt latency of __ZLI__ RTOS setup @$\;\si{100Hz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_zli_latency_200Hz_50ns.png" title="Interrupt latency @200Hz of __ZLI__ RTOS setup" class="noborder"><figcaption>Interrupt latency of __ZLI__ RTOS setup @$\;\si{200Hz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_zli_latency_2kHz_50ns.png" title="Interrupt latency @2kHz of __ZLI__ RTOS setup" class="noborder"><figcaption>Interrupt latency of __ZLI__ RTOS setup @$\;\si{2kHz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_zli_latency_20kHz_50ns.png" title="Interrupt latency @20kHz of __ZLI__ RTOS setup" class="noborder"><figcaption>Interrupt latency of __ZLI__ RTOS setup @$\;\si{20kHz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_zli_latency_200kHz_50ns.png" title="Interrupt latency @200kHz of __ZLI__ RTOS setup" class="noborder"><figcaption>Interrupt latency of __ZLI__ RTOS setup @$\;\si{200kHz}\;$</figcaption> </figure>

<h4 class="sp"><span>Jitter measurements</span></h4>

<figure class="oszi" markdown=1> <img src="./pics/os_zli_jitter_100Hz_20ns.png" title="Interrupt jitter @100Hz of __ZLI__ RTOS setup" class="noborder"><figcaption>Interrupt jitter of __ZLI__ RTOS setup @$\;\si{100Hz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_zli_jitter_200Hz_20ns.png" title="Interrupt jitter @200Hz of __ZLI__ RTOS setup" class="noborder"><figcaption>Interrupt jitter of __ZLI__ RTOS setup @$\;\si{200Hz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_zli_jitter_2kHz_20ns.png" title="Interrupt jitter @2kHz of __ZLI__ RTOS setup" class="noborder"><figcaption>Interrupt jitter of __ZLI__ RTOS setup @$\;\si{2kHz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_zli_jitter_20kHz_20ns.png" title="Interrupt jitter @20kHz of __ZLI__ RTOS setup" class="noborder"><figcaption>Interrupt jitter of __ZLI__ RTOS setup @$\;\si{20kHz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_zli_jitter_200kHz_20ns.png" title="Interrupt jitter @200kHz of __ZLI__ RTOS setup" class="noborder"><figcaption>Interrupt jitter of __ZLI__ RTOS setup @$\;\si{200kHz}\;$</figcaption> </figure>

### Measurement results documentation  ###
>Fill in Table 5.5. and add it to the report.

<center>
Latency and jitter table running __ZLI RTOS__  setup from FLASH.

| ePWM1A Freq     | Interrupt latency | Interrupt jitter |
|:---------------:|:-----------------:|:----------------:|
| $\si\{100Hz\}$  | $\si\{330 ns\}$   | $\si\{122 ns\}$  |
| $\si\{200Hz\}$  | $\si\{330 ns\}$   | $\si\{96 ns\}$   |
| $\si\{2kHz\}$   | $\si\{330 ns\}$   | $\si\{84 ns\}$   |
| $\si\{20kHz\}$  | $\si\{330 ns\}$   | $\si\{20 ns !!!\}$   |
| $\si\{200kHz\}$ | $\si\{330 ns\}$   | $\si\{78 ns\}$   |

</center>

# Conclusion #
Since the latency value doesn't change much within a setup, all latency and jitter tables has been merged into a single one.

<center>
Avarage latencys and jitter values in $[\si{ns}]$ per ePWM frequency.

| setup            | avg. latency | 100 Hz | 200 Hz | 2 kHz | 20 kHz | 200 kHz |
|:----------------:|:------------:|:------:|:------:|:-----:|:------:|:-------:|
| non-OS (ram)     | 220          | 26     | 26     | 26    | 26     | 26      |
| non-OS (flash)   | 330          | 26     | 25     | 24    | 24     | 24      |
| RTOS HWI         | 1610         | 28     | 85     | 57    | 89     | 120     |
| RTOS SWI         | 3760         | 150    | 130    | 130   | 150    | NA      |
| RTOS ZLI         | 330          | 122    | 96     | 84    | 20     | 78      |

</center>

<spar>The code execution performance depends on several device parameters that needs to be considered as given (e.g. hardware induced, max. ratings). Indeed, there are various options to increase the performance in terms of "instruction throughput" to meet highest requirements in time-critical applications.</spar>
<spar>The high degree of flexibility regarding code sectioning __without__ the need of a memory management unit and the automatic, efficient interrupt full context save/restore mechanism are some of the benefits when using a modern RISC processor.</spar>
<spar>The Harvard architecture provides separate hardware pathways from instruction and data memories to the CPU. This enables the computational core, instruction and data fetches to be performed in parallel. The CPU can read instructions and data while it writes data simultaneously to provide a almost singlecycle mnemonic across the instruction pipeline. All RAM blocks offer 0-wait R/W access that is, indeed, necessary for computational cores, outlining about __85%__ single-cycle instructions.</spar>
<spar>Due to the nature of __modified__ Harvard architectures, the C28xx provides instruction fetching in addition via its data memory bus (i.e. from RAM), rather than only be able to load instructions from program memory sections (i.e. from FLASH, ROM). Another great benefit of modified Harvard architectures is the ability to boot from almost all peripheral interfaces such as SCI/UART, SPI, McBSP or even via large controller area networks.</spar>
<spar>According to the <lkey>F2833x Code Execution Performance</lkey> characteristics, the performance degradation between RAM and internal pipelined FLASH execution is approximately $\si{33 \%}$ since the instruction throughput relation is outlined to be $\si{150 MIPS}/\si{100 MIPS}$. The relation factor of 1.5 is perfectly reflected by the measurement results when comparing the latency values of "_non-OS (ram)_" and "_non-OS (flash)_" since $\si{220 ns}\cdot 1.5 \,=\,\si{330 ns}$ </spar>

<center>
<figure style="width:90%;""> <img src="./pics/flash_ram_performance_degrad.png" title="F2833x Code Execution Performance" class="noborder"><figcaption>F2833x Code Execution Performance[^fnCodeExec]</figcaption> </figure>
</center>

<spar>As described in <lkey>TMS320C28x CPU and Instruction Set (Rev. F)</lkey>[^fnCpuInstr], section __3.4__ _Standard Operation for Maskable Interrupts_, the C28xx CPU provides automatic context save and restore mechanism for all necessary core registers. In __Table 3-4__ <lkey>Register Pairs Saved and SP Positions for Context Saves</lkey>, the automatic context save procedure is listed in detail. This could be used to determine what portion of the interrupt latency is caused by the context save.</spar>
<spar>It should be noticed to not missunderstand the preceeding 'automatic' of the context save mechanismn. This doesn't mean that the push/pop operations of this registers are processed faster than a software implemented equivalent but only that the interrupt context related push/pop instructions are "silicon" programmed because they __have to__ be performed for every valid IRQ, independent of the customer application implementations. As a result of _little Endian_ memory model, 16-Bit op-code arguments needs to be swapped in the following instruction listings.

<center>
Table 3-4. Register Pairs Saved, silicon instruction listings and needed cycles

| No      | Register Pairs   | silicon instruction    | cycles |
|:-------:|:-----------------|:-----------------------|:------:|
| 1st     | STO, T           | ```PUSH T:ST0```       | 1      |
| 2nd     | AL, AH           | ```PUSH ACC```         | 1      |
| 3rd     | PL, PH           | ```PUSH P```           | 1      |
| 4th     | AR0, AR1         | ```PUSH AR1:AR0```     | 1      |
| 5th     | ST1, DP          | ```PUSH DP:ST1```      | 1      |
| 6th     | IER, DBGSTAT     | ```PUSH DBGSTAT:IER``` | 1      |
| 7th     | PCL. PCH         | ```PUSH PCH:PCL```     | 1      |

</center>

Taking the measurements from non-OS setup RAM execution, the automatic context save induced latency could be determined by:

$$\frac{7}{\si{150 MHz}}\cdot \frac{\si{100 \%}}{\si{220 ns}}\,=\,\si{21.2 \%}$$

Due to this result it is immediately clear why the design of F2833x does not provide a silicone __full__ context save/restore mechanism since this would increase the interrupt latency by another 8 cycles (see Table 2-1).
The stack layout prescribed by Table 3-4 has been verified during a CCS7 debug session (see image after Table 2-1).

<center>
Table 2-1. CPU Register Summary

| Register |    Size   |       Description        | context  |
|----------|-----------|--------------------------|----------|
| __ACC__  | 32-bits   | __Accumulator__          | __auto__ |
| __AH__   | 16-bits   | __High half of ACC__     | __auto__ |
| __AL__   | 16-bits   | __Low half of ACC__      | __auto__ |
| XAR0     | 16-bits?? | Auxiliary register 0     |          |
| __AR0__  | 16-bits   | __Low half of XAR0__     | __auto__ |
| XAR1     | 32-bits   | Auxiliary register 1     |          |
| __AR1__  | 16-bits   | __Low half of XAR1__     | __auto__ |
| XAR2     | 32-bits   | Auxiliary register 2     |          |
| XAR3     | 32-bits   | Auxiliary register 3     |          |
| XAR4     | 32-bits   | Auxiliary register 4     |          |
| XAR5     | 32-bits   | Auxiliary register 5     |          |
| XAR6     | 32-bits   | Auxiliary register 6     |          |
| XAR7     | 32-bits   | Auxiliary register 7     |          |
| AR2      | 16-bits   | Low half of XAR2         |          |
| AR3      | 16-bits   | Low half of XAR3         |          |
| AR4      | 16-bits   | Low half of XAR4         |          |
| AR5      | 16-bits   | Low half of XAR5         |          |
| AR6      | 16-bits   | Low half of XAR6         |          |
| AR7      | 16-bits   | Low half of XAR7         |          |
| __DP__   | 16-bits   | __Data-page pointer__    | __auto__ |
| __IFR__  | 16-bits   | __Interrupt flag reg__   |          |
| __IER__  | 16-bits   | __Interrupt enable reg__ | __auto__ |
| DBGIER   | 16-bits   | Debug interrupt enable   |          |
| __P__    | 32-bits   | __Product register__     | __auto__ |
| __PH__   | 16-bits   | __High half of P__       | __auto__ |
| __PL__   | 16-bits   | __Low half of P__        | __auto__ |
| PC       | 22-bits   | __Program counter 0x3F__ | __auto__ |
| RPC      | 22-bits   | Return program counter   |          |
| SP       | 16-bits   | Stack pointer            |          |
| __ST0__  | 16-bits   | __Status register 0__    | __auto__ |
| __ST1__  | 16-bits   | __Status register 1__    | __auto__ |
| XT       | 32-bits   | Multiplicand register    |          |
| __T__    | 16-bits   | __High half of XT__      | __auto__ |
| TL       | 16-bits   | Low half of XT           |          |

It should be noticed that additional context guarding must be provided when an application makes use of the core auxiliary registers XAR1...XAR7 from different contexts (i.e. from ISR and non-ISR contexts)!

<a href="./pics/debug_context_restore_b.png" target="_blank"><figure style="margin-top: 3em;" class="noborder"> <img src="./pics/debug_context_restore_b.png" title="Stack layout and automatic context restore verification" class="noborder"><figcaption>Stack layout and automatic context restore verification</figcaption> </figure></a>
</center>

As mentioned above, the performance deterioration induced when fetching data and/or instructions from FLASH memory sections is quite noticeable, but can in many cases be reduced or eliminated. The modified Harward architecture behavior has also been mentioned earlyer in this chapter and the ease of memory management without the need of a MMU has been addressed, too. As a simple but powerfull example, the CCS sources of ELT131_03_02 has been extended by a single code line what eliminates the interrupt latency deterioration from non-OS FLASH setup.

The XINT1_isr() disassembly of the non-modified FLASH version shows that ISR entry point is placed at 0x3389d5 of the internal address space.

```objdump
124     void XINT1_isr(void) {
        XINT1_isr():
3389d5:   761B        ASP
3389d6:   FFF0        PUSH         RB
3389d7:   E20000BD    MOV32        *SP++, STF
3389d9:   E6300600    SETFLG       RNDF32=1,RNDF64=1
3389db:   FE02        ADDB         SP, #2
3389dc:   2942        CLRC         OVM|PAGE0
(...)
```

From the memory linker command file F28335.cmd it could be determined that this addresses FLASH block A. 

```cmd
MEMORY
{
PAGE 0:    /* Program Memory */
           /* Memory (RAM/FLASH/OTP) blocks can be moved to PAGE1 for data allocation */

   ZONE0       : origin = 0x004000, length = 0x001000     /* XINTF zone 0 */
   RAML0       : origin = 0x008000, length = 0x001000     /* on-chip RAM block L0 */
   RAML1       : origin = 0x009000, length = 0x001000     /* on-chip RAM block L1 */
   RAML2       : origin = 0x00A000, length = 0x001000     /* on-chip RAM block L2 */
(...)
   FLASHC      : origin = 0x328000, length = 0x008000     /* on-chip FLASH */
   FLASHA      : origin = 0x338000, length = 0x007F80     /* on-chip FLASH */
                       /* 0x3389d5  <-------- */
   CSM_RSVD    : origin = 0x33FF80, length = 0x000076     /* Part of FLASHA.  Program with all 0x0000 when CSM is in use. */
   BEGIN       : origin = 0x33FFF6, length = 0x000002     /* Part of FLASHA.  Used for "boot to Flash" bootloader mode. */
   CSM_PWL     : origin = 0x33FFF8, length = 0x000008     /* Part of FLASHA.  CSM password locations in FLASHA */
   OTP         : origin = 0x380400, length = 0x000400     /* on-chip OTP */

(...)

SECTIONS
{
   /* Allocate program areas: */
   .cinit              : > FLASHA      PAGE = 0
   .pinit              : > FLASHA,     PAGE = 0
   .text               : > FLASHA      PAGE = 0
   codestart           : > BEGIN       PAGE = 0
   ramfuncs            : LOAD = FLASHD,                 /* <--------- *
                         RUN = RAML0,                   /* <--------- */
                         LOAD_START(_RamfuncsLoadStart),
                         LOAD_END(_RamfuncsLoadEnd),
                         RUN_START(_RamfuncsRunStart),
                         LOAD_SIZE(_RamfuncsLoadSize),
                         PAGE = 0
(...)
```

To overcome the dogmatic and non-modified harward architecture behavior, simply tell the compiler to be pragmatic and call the XINT1 IRQ handler from data memory section "_ramfuncs_"!

```c
#pragma CODE_SECTION(XINT1_isr, "ramfuncs");
```

This results in an identical assembly listing with a ISR entry point placed at address 0x8000 of the internal address space. According to the linker command file line 78, this addresses the on-chip RAM block L0.

```c-objdump
124     void XINT1_isr(void) {
        RamfuncsRunStart, XINT1_isr():
008000:   761B        ASP
008001:   FFF0        PUSH         RB
008002:   E20000BD    MOV32        *SP++, STF
008004:   E6300600    SETFLG       RNDF32=1,RNDF64=1
008006:   FE02        ADDB         SP, #2
008007:   2942        CLRC         OVM|PAGE0
(...)
```

The picture below shows the interrupt latencys of the original and the modified version of ELT131_LAB_03_02. The time cursors are placed such to show the latency difference between both versions which is approximately $\si{110 ns}$ as expected. 
 
<figure class="oszi" markdown=1> <img src="./pics/ram_flash_overlayed_50ns.png" title="Latency comparison of non-OS setup running from FLASH, w/ and w/o linking XINT1_isr() to RAM memory" class="noborder"><figcaption>Latency comparison of non-OS setup running from __FLASH__, w/ and w/o linking __XINT1_isr()__ to __RAM__</figcaption> </figure>

Indeed this technique is not restricted to be used for time critical IRQ handlers or other functions. Also data symbols with the access specifiers ```const int16_t cSineTable[] = {...``` could be linked into RAM. Granted, it appears first to be senseless since the const specifier mostly implies const-nes and is therefor used to tell the compiler to not place the symbol data into RAM section, for example: 

```c
const char* cWelcomeMsg="Starting device, please wait...";
```

But for a const declared sine table like this one below, it could increase performance (i.e. reduce time to fetch the next sample) when placing the array in the fast RAM section.    

```c
const double cSine[] = {-0.998, -0.995, -0.988, -0.980, -0.968, -0.955};
```

# Non-OS setup (FLASH) vs. Zero latency #

Zero latency operation may be used to ensure minimal interrupt-to-IRQ-handler delays, i. e. _minimum-latency-interrupt_. Compared to interrupt latencys in [part 3 (HWI)](#ti-rtos-hardware-interrupt-setup-hwi-part-3) and [part 4 (SWI)](#ti-rtos-software-interrupt-setup-swi-part-4), _zero latency_ configuration results in _most smallest latency_ of all TI-RTOS setups.



<figure class="oszi" markdown=1> <img src="./pics/non-os_latency_20kHz_20ns.png" title="Interrupt latency @20kHz of __non-OS__ setup running from __RAM__ (SYSCLKOUT=$\si{150MHz}$)" class="noborder"><figcaption>Interrupt latency of __non-OS__ setup running from __RAM__ ($\,F_{CPU}\,=\,\si{150MHz}\,$) @$\;\si{20kHz}\;$</figcaption> </figure>

<figure class="oszi" markdown=1> <img src="./pics/os_latency_zli_20kHz_50ns.png" title="Interrupt latency @20kHz of __RTOS__ setup running from __FLASH__ (SYSCLKOUT=$\si{150MHz}$)" class="noborder"><figcaption>Interrupt latency of __RTOS__ setup running from __FLASH__ ($\,F_{CPU}\,=\,\si{150MHz}\,$) @$\;\si{20kHz}\;$</figcaption> </figure>

# Open questions #
## Keyword __interrupt ##
When to preceed ISR prototypes by the preprocessor/linker directive/keyword **__interrupt** ?

From [_SYS/BIOS (TI-RTOS Kernel) v6.46 User's Guide_ ](http://www.ti.com/lit/ug/spruex3q/spruex3q.pdf), page 57, chapter:
__3.4 Hardware Interrupts:__
>(...) Assembly language ISRs that do not interact with SYS/BIOS can be specified with Hwi_plug(). Such ISRs must do their own context preservation. **They may use the "interrupt" keyword, C functions, or assembly language functions.**

In other words:
Regardless of whether to implement an IRQ callback handler in assembler or C, __it have to be__ preceeded by the (linker-) keyword **__interrupt** in case of bypassing SYS/BIOS HWI module.

Should it not rather be:
>(...) ~~Assembly language~~ ISRs that do not interact with SYS/BIOS can be specified with Hwi_plug(). Assembly language ~~Such~~ ISRs must do their own context preservation. They may use the "interrupt" keyword, C functions, or assembly language functions.

## Zero latency PIE group ##
According to the [RTOS API documentation](http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/bios/sysbios/6_33_00_19/exports/bios_6_33_00_19/docs/cdoc/ti/sysbios/family/c28/Hwi.html#zero.Latency.I.E.R.Mask),

>CPU interrupts specified in this mask (which corresponds to the 16-bit IER register) will __never be disabled__. This means that the disable, enable, and restore calls leave the zero latency CPU interrupts enabled after being called. Zero latency operation may be used to ensure __minimal interrupt-to-ISR time__ for __non-BIOS__ interrupt handlers in applications that demand low latency.

>It is important to note that zero latency and non-zero latency PIE interrupts may not share a common PIE group. The entire PIE group whose bit is set in the zeroLatencyIERMask will be treated as zero latency.

__doc htmls__
__Register view searchable__

[^fnCodeExec]: __F2833x Code Execution Performance__ http://e2e.ti.com/cfs-file/__key/communityserver-discussions-components-files/171/6740.Capture.JPG

[^fnCpuInstr]: __TMS320C28x CPU and Instruction Set (Rev. F)__